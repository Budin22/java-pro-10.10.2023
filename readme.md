# Java pro course 10.10.2023

### Stream API
### Task_17
ВАЖЛИВО! Всі завдання виконуються виключно із застосуванням Stream API

1.1 Дан клас Product, який складається з властивостей:

- тип

- ціна

1.2 Реалізувати метод отримання всіх продуктів у вигляді списку, категорія яких еквівалентна “Book” та ціна більш ніж 250.

2.1 Дан клас Product, який складається з властивостей:

- тип

- ціна

- можливість застосування знижки

2.2 Реалізувати метод отримання всіх продуктів як списку, категорія яких еквівалентна “Book” і з можливістю застосування знижки. Фінальний список повинен містити продукти з застосованою знижкою 10%.

Так, якщо Продукт A був з ціною 1.0 USD, то його фінальна ціна залишатиметься 0.9 USD

3.1 Даний клас Product, який складається з властивостей:

- тип

- ціна

- можливість застосування знижки

3.2 Реалізувати метод отримання найдешевшого продукту з категорії “Book”

3.3 У випадку, якщо жоден продукт не знайдено (ситуація, коли немає продукту з категорією), викинути виняток з повідомленням “Продукт [категорія: ім'я_категорії] не знайдено”.

4.1 Даний клас Product, який складається з властивостей:

- тип

- ціна

- можливість застосування знижки

- дата додавання (можна використовувати тип даних java.time.LocalDate, java.time.LocalDateTime або java.util.Date)

4.2 Реалізувати метод отримання трьох останніх доданих продуктів

5.1 Цей клас Product, який складається з властивостей:

- тип

- ціна

- можливість застосування знижки

- дата додавання (можна використовувати тип даних java.time.LocalDate, java.time.LocalDateTime або java.util.Date)

5.2 Реалізувати метод калькуляції загальної вартості продуктів, які відповідають наступним критеріям:

- продукт додано протягом поточного року

- продукт має тип “Book”

- ціна продукту не перевищує 75

** 6.1 Дан клас Product, який складається з властивостей:

- ідентифікаційний номер

- тип

- ціна

- можливість застосування знижки

– дата додавання (можна використовувати тип даних java.time.LocalDate, java.time.LocalDateTime або java.util.Date)

** 6.2 Реалізувати метод групування об'єктів за типом продукту. Таким чином результатом виконання методу

буде тип даних “Словник”, що зберігає пару ключ-значення: {тип: список_продуктів}

Наприклад:

{

	“Book”, 

	[

		{type: “Book”, price: 100, discount: false, createDate: 01-01 -2022}, 

		{…}, 

		{…}

	]

},

{

	“Toy”, 

	[

		{type: “Toy”, price: 100, discount: true, createDate: 10–102022}, 

		{…}

	]

}



### Algorithm
### Task_15
1. Реалізувати алгоритм "Швидкого сортування"
2. Реалізувати алгоритм "Сортування перемішуванням (Шейкерне сортування)"

### Map and Set
### Task_14

0. Створити новий пакет coffee.order

1. Створити клас CoffeeOrderBoard. Клас є цифровим поданням черги замовлень у кав'ярні.

Цей клас містить список замовлень.

2. Створити клас Order. Клас є цифровим поданням замовлення. Даний клас містить номер замовлення та ім'я людини, що його замовила.

3. Реалізувати метод add у класі CoffeeOrderBoard. Даний метод додає нове замовлення та надає замовленню номер (натуральний порядок).

Натуральний порядок (natural ordering) означає, що й у останнього замовлення номер 86, то наступний буде 87.

Не може бути такої ситуації, що номер повторюється у межах одного об'єкта типу CoffeeOrderBoard.

4. Реалізувати метод deliver у класі CoffeeOrderBoard. Цей метод видає найближче у черзі замовлення. Видача супроводжується видаленням замовлення зі списку.

5. Реалізувати метод deliver у класі CoffeeOrderBoard. Даний метод видає замовлення з певним номером. Видача супроводжується видаленням замовлення зі списку.

Даний метод обробляє ситуацію, коли замовлення, що надійшло пізніше, готове раніше.

6. Реалізувати метод draw у класі CoffeeOrderBoard. Цей метод виводить у консоль інформацію про поточний стан черги у порядку найближчого до видачі замовлення.

Наприклад:

=============

Num | Name

4 | Alen

27 | Yoda

33 | Obi-van

34 | John Snow




### Map
### Task_13

0. Створити клас FileNavigator. Клас призначений для зберігання списку файлів, які розташовані на конкретному шляху.

Наприклад: /path/to/file-> [files.txt, firstApp.java]

1. Створити клас FileData. Клас представляє конкретний файл і складається з: ім'я файлу, розміру в байтах, шлях до файлу.

2. Реалізувати метод add у класі FileNavigator. Цей метод додає файл за вказаним шляхом. Якщо шлях вже існує, новий файл необхідно додати до списку, вже пов'язаному з відповідним шляхом. ВАЖЛИВО: Шлях – унікальне значення і не повинно повторюватися.

3. Реалізувати метод find у класі FileNavigator. Метод повертає список файлів, пов'язаних з шляхом переданим як параметр.

4. Реалізувати метод filterBySize у класі FileNavigator. Метод повертає список файлів, розмір (в байтах) яких не перевищує значення, передане як параметр.

5. Реалізувати метод remove у класі FileNavigator. Метод видаляє шлях і пов'язані з ним файли, виходячи з значення шляху, переданого як параметр.

6. * Реалізувати метод sortBySize у класі FileNavigator. Метод сортує всі наявні файли за розміром (за зростанням), потім повертає список відсортованих файлів.

7. ** Реалізувати перевірку консистентності у методі add у класі FileNavigator. Не дозволяти додавати значення і повідомити про це в консолі, при спробі додати значення FileData значення шляху якого не відповідає шляху-ключу, що веде до списку файлів.

Наприклад:

Має бути помилка, оскільки шлях-ключ і шлях до файлу не співпадають

Шлях: /path/to/file

FileData: {name: ..., size: ..., path: /another/path/}

### Concurrency
### Task_11(Plus)

Додаткове завдання (не обовʼязково)

1. Створити клас, обʼєкти якого мають метод, що приймає URL веб-сторінки, та шлях до директорії.
2. За заданим URL необхідно прочитати вміст веб-сторінки (HTML) та пропарсити його
3. Після парсингу дістати з веб-сторінки всі зображення (img-теги) та завантажити кожне зображення і зберегти і вказаній директорії (з пункту 1).
4. Зображення треба завантажувати окремими потоками. Підсказка: кожен img елемент може містити атрибут `src` наприклад <img src="https://some-img.com/img1.jpg" alt="Dog"/>
5. Кількість потоків має бути обмежена. Скажімо максимальне число потоків відповідає кількості ядер на вашій машині, але не менше 2.
6. Після завантаження всіх фото записати результат у файл з назвою у форматі: result_<CURRENT_DATE>.json. Результат має бути у форматі JSON, приклад
{
   "url": "https://www.wikipedia.org/",
   "dateTime": "2023-10-10 12:00:00",
   "scaned": 4,
   "success": 2,
   "images": [
       {
       "path": "C:\Users\vasyl\images\img1.jpg",
       "label": "Beautiful landscape"
       },
       {
       "path": "C:\Users\vasyl\images\cat1010.jpg",
       "label": "Cat1"
       }
   ]
}

7. Атрибути цього JSON документу:
- url - URL веб-сторінки, що пропарсили
- dateTime - дата та час завершення парсингу
- scanned - скільки всього img-елементів було на веб-сторінці
- success - скільки всього img-елементів було на веб-сторінці
- images - список обʼєктів, що мають атрибути:
- path - шлях де збережено зображення
- label - назва взята із атрибуту alt елементу img
8. * Створити консольний інтерфейс користувача
9. ** Створити GUI (будь-яка бібліотека чи фреймворк)
10. ** Який саме інтерфейс буде запускатися вирішувати на основі змінної оточення (environment variable) з назвою INTERFACE_MODE, її можливі значення "gui", "console", за дефолтом "console"

### Concurrency
### Task_11

0.1. Створити клас ThreadSafeList. Клас реалізовує потокобезпечну колекцію.

0.1 Реалізувати методи: add, remove, get

add додає елемент до списку
get повертає елемент зі списку за даним числовим індексом
remove видаляє або переданий елемент зі списку, або елемент зі списку за індексом
0.2 Методи повинні бути реалізовані з урахуванням того, що вони будуть використовуватися в конкурентному середовищі.

1.1. Створити клас PetrolStation. Клас представляє заправну станцію.

1.2 Клас PetrolStation містить властивість дійсного типу (double) з ім'ям amount. Ця властивість становить кількість палива на станції.

1.3 У класі PetrolStation реалізувати метод doRefuel. Метод набуває значення дійсного типу. При виконанні даного методу йде віднімання палива, що запитується, з доступної кількості.

1.4 Одна заправка триває від 3-10 секунд. Після закінчення часу очікування, здійснює віднімання значення з amount

1.5 Заправна станція може одночасно обслуговувати не більше 3 запитів.

### Multithreading
### Task_10
1. Створити клас ValueCalculator

2. У класі ValueCalculator додати:

- властивість-масив із дійсних чисел

- властивість, що відображає розмір масиву (мінімально 1 000 000)

- властивість, що відображає половину розміру масиву

3. У класі ValueCalculator додати метод Метод виконує:

- Зафіксувати час старту виконання методу: long start = System.currentTimeMillis()

- Заповнити масив одиницями або будь-якими іншими однаковими значеннями

- Розбити масив на два масиви однакової величини:

Приклад розподілу одного масиву на два:

System.arraycopy(arr, 0 , a1, 0, half);

System.arraycopy(arr, half, a2, 0, half);

- Створити два потоки, у кожному з яких пройтися одним із раніше отриманих масивів.

Присвоїти його значенням нові значення, сформовані виразом: (float)(arr[i] * Math.sin(0.2f + i / 5) * Math.cos(0.2f + i / 5) * Math.cos(0.4f + i / 2))

- Виконати зворотне склеювання двох масивів в один початковий

Приклад зворотного склеювання:

System.arraycopy(a1, 0, arr, 0, h);

System.arraycopy(a2, 0, arr, h, h);

- Обчислити витрачений час від старту до завершення програми та виведення його в консоль.


### Exceptions
### Task_8

1. Створити Клас ArrayValueCalculator

2. Створити метод doCalc. На вхід до методу подається двомірний рядковий масив розміром 4х4.

3. При передачі масиву іншого розміру в метод doCalc необхідно викинути виняток ArraySizeException.

4. Метод doCalc повинен пройтися за всіма елементами масиву і перетворити в int (використовувати Integer#parseInt) і підсумувати. Після загального підсумовування метод повертає фінальний результат у вигляді int.

5. Якщо в якомусь елементі масиву перетворення не вдалося (наприклад, в комірці лежить символ або текст замість числа), тоді викинути виняток ArrayDataException, з деталізацією в якому саме комірці лежать невірні дані.

6. У методі main() викликати отриманий метод, обробити можливі винятки ArraySizeException та ArrayDataException, та вивести результат розрахунку.

7. ** Необхідно дотримуватись усіх правил збереження контексту викинутого виключення.

8. ** При вилові винятків у процесі перетворення, взяти до уваги винятки, що викидаються іншими (сторонніми) методами, що використовуються.

### Data type
### Task_7

1. Створити порожній проект в IntelliJ IDEA

2. Створити метод findSymbolOccurance. Метод приймає як параметр рядок і символ. Необхідно обчислити, скільки разів символ зустрічається в переданому рядку і повернути це числове значення.

3. Створити метод findWordPosition. Метод приймає як параметри два рядки (source, target). Необхідно з'ясувати, чи є target (підрядок) частиною рядка source. Якщо так, тоді повернути номер позиції (індекс) першого елемента підрядка у рядку, інакше повернути -1.

Приклад 1:

Source: Apollo

Target: pollo

Result: 1

Приклад 2:

Source: Apple

Target: Plant

Result: -1

4. Створити метод stringReverse. Метод приймає як параметр - рядок. Необхідно її розгорнути та повернути змінений варіант.

Наприклад:

Hello -> olleH

5. Створити метод isPalindrome. Метод приймає як параметр - рядок. Необхідно Перевірити, чи є переданий рядок паліндромом. Якщо так, тоді повернуть true, інакше false.

Приклад 1:

ERE -> true

Приклад 2:

Allo -> false

6. * Створити масив зі слів String[] words = {"apple", "orange", "lemon", "banana", "apricot", "avocado" , "broccoli", "carrot", "cherry", "garlic", "grape", "melon", "leak", "kiwi", "mango", "mushroom", "nut", "olive", " pea", "peanut", "pear", "pepper", "pineapple", "pumpkin", "potato"};

При запуску програми комп'ютер загадує слово, запитує відповідь у користувача,

порівнює його із загаданим словом та повідомляє чи правильно відповів користувач. Якщо слово не вгадано, комп'ютер показує літери, які стоять на своїх місцях.

apple – загадане

apricot - відповідь гравця

ap############# (15 символів, щоб користувач не міг дізнатися довжину слова)



### Task_6

1. Створити порожній проект у IntelliJ IDEA, створити клас HomeWorkApp і прописати в ньому метод main().

2. Створіть метод printThreeWords(), який під час виклику повинен надрукувати в стовпець у три слова: Orange, Banana, Apple.

Orange

Banana

Apple

3. Створіть метод checkSumSign(), у тілі якого оголосіть дві int змінні a і b, та ініціалізуйте їх будь-якими значеннями, якими захочете. Далі метод повинен підсумувати ці змінні, і якщо їх сума більша або дорівнює 0, то вивести в консоль повідомлення "Сума позитивна", інакше - "Сума негативна";

4. Створіть метод printColor() у тілі якого задайте int змінну value та ініціалізуйте її будь-яким значенням. Якщо значення менше 0 (0 включно), то в консоль метод повинен вивести повідомлення "Червоний", якщо лежить в межах від 0 (0 виключно) до 100 (100 включно), то "Жовтий", якщо більше 100 (100 виключно) - "Зелений";

5. Створіть метод compareNumbers(), у тілі якого оголосіть дві int змінні a і b, та ініціалізуйте їх будь-якими значеннями, якими захочете. Якщо a більше або одно b, необхідно вивести в консоль повідомлення “a >= b”, інакше “a < b”;

6. Написати метод, який приймає на вхід два цілих числа і перевіряє, що їхня сума лежить в межах від 10 до 20 (включно), якщо так – повернути true, інакше – false.

7. Написати метод, якому як параметр передається ціле число, метод повинен надрукувати в консоль, чи додатнє число передали або від’ємне. Примітка: нуль вважаємо позитивним числом.

8. Написати метод, якому як параметр передається ціле число. Метод повинен повернути true, якщо число є негативним, і повернути false якщо позитивне.

9. Написати метод, якому як аргументи передається рядок і число, метод повинен надрукувати в консоль зазначений рядок, вказану кількість разів;

10. * Написати метод, який визначає, чи є рік високосним, і повертає boolean (високосний – true, не високосний – false). Кожен 4-й рік є високосним, крім кожного 100-го, причому кожен 400-й – високосний.



### My goal for this course

- to have a strong foundation knowledge in Java
- to have a gaudiness from an experience developer
- to see more troubleshoot handling
- to be in a group of people who want to grow and develop
- to have a mentor at this course
- to have interesting and challenging home tasks
- improve my skills in resolving different ensue